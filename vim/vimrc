" vim:set ts=2 sw=2 :
" neobundleの設定{{{
set nocompatible               " be iMproved
filetype off                   " required!
filetype plugin indent off     " required!
if has('vim_starting')
  set runtimepath&
  set runtimepath+=~/.vim/bundle/neobundle.vim/
  call neobundle#rc(expand('~/.vim/bundle/'))
endif
NeoBundle 'Shougo/neobundle.vim'
NeoBundle 'Shougo/vimproc', {
      \ 'build' : {
      \   'windows' : 'echo "Sorry, cannot update vimproc binary file in Windows."',
      \   'cygwin' : 'make -f make_cygwin.mak',
      \   'mac' : 'make -f make_mac.mak',
      \   'unix' : 'make -f make_unix.mak',
      \   },
      \ }
NeoBundle 'Shougo/vimshell'
NeoBundle 'Shougo/unite.vim'
"" Unite Source
NeoBundle 'tsukkee/unite-help'
NeoBundle 'kmnk/vim-unite-giti'
NeoBundle 'h1mesuke/unite-outline'
NeoBundle 'basyura/wwwrefe.vim'
NeoBundle 'ujihisa/unite-colorscheme'
NeoBundle 'mattn/unite-advent_calendar'
NeoBundle 'tsukkee/unite-tag'
NeoBundle 'osyo-manga/unite-quickfix'
NeoBundle 'ujihisa/unite-rake'
NeoBundle 'basyura/unite-rails'
NeoBundle 'Shougo/unite-build'
NeoBundle 'hewes/unite-gtags'
"" ネタのUnite Source
NeoBundle 'mattn/unite-nyancat'
NeoBundle 'osyo-manga/unite-shimapan'
"" Bundles
NeoBundle 'Shougo/neocomplcache'
NeoBundle 'Shougo/neosnippet'
NeoBundle 'Shougo/vimfiler'
NeoBundle 'Shougo/vinarise'
NeoBundle 'thinca/vim-ref'
NeoBundle 'mattn/hahhah-vim'            " ステータスラインにハァハァ
NeoBundle 'tpope/vim-abolish'           " キャメルケース,スネークケース等の変換
NeoBundle 'kana/vim-textobj-user'       " textobjを作るための物
NeoBundle 'kana/vim-textobj-fold'       " 折りたたまれた部分をtextobjに
NeoBundle 'kana/vim-textobj-indent'     " インデントされた部分をtextobjに
NeoBundle 'h1mesuke/textobj-wiw'        " wordの中の単語をtextobjに
NeoBundle 'tomtom/tcomment_vim'         " コメントのトグル
NeoBundle 'thinca/vim-quickrun'
NeoBundle 'errormarker.vim'
NeoBundle 'mattn/gist-vim'
NeoBundle 'h1mesuke/vim-alignta'        " テキストを表みたいな感じに整形
NeoBundle 'taku-o/vim-toggle'           " true,falseのトグル
NeoBundle 'dannyob/quickfixstatus'      " カーソル行のquickfixをコマンド行に表示
NeoBundle 'mattn/webapi-vim'
NeoBundle 'tyru/open-browser.vim'
NeoBundle 'sudo.vim'
NeoBundle 'tpope/vim-fugitive'          " git操作
NeoBundle 'gregsexton/gitv'             " gitk みたいなもの fugitiveが必要
NeoBundle 'kana/vim-tabpagecd'          " タブごとにカレントディレクトリ設定
NeoBundle 'koron/nyancat-vim'           " nyancatのアニメ
NeoBundle 'nefo-mi/nyan-modoki.vim'     " ステータスラインに顔文字
NeoBundle 'taglist.vim'
NeoBundle 'yomi322/vim-gitq', {'depends' :
      \ ['thinca/vim-quickrun']
      \ }                                " Gitコマンドをquickrunに投げる
NeoBundle 'osyo-manga/shabadou.vim', {'depends' :
      \ ['thinca/vim-quickrun', 'Shougo/vimproc', 'Shougo/unite.vim',
      \ 'osyo-manga/unite-quickfix']
      \ }                                " quickrunをカスタマイズ
NeoBundle 'osyo-manga/vim-watchdogs', {'depends' :
      \ ['thinca/vim-quickrun', 'Shougo/vimproc', 'osyo-manga/shabadou.vim',
      \ 'osyo-manga/unite-quickfix']
      \ }
NeoBundle 'thinca/vim-partedit'         " バッファ内の一部を別バッファで編集(例:html内のjavascript)
NeoBundle 'matchit.zip'
NeoBundle 'kana/vim-arpeggio'
NeoBundle 'vimtaku/hl_matchit.vim.git'
NeoBundle 'itchyny/thumbnail.vim'
NeoBundle "osyo-manga/vim-anzu"           " 現在の検索位置を表示
NeoBundle "spolu/dwm.vim"                 " タイル型
"" Colorscheme
NeoBundle 'molokai'
NeoBundle 'pyte'
NeoBundle 'Zenburn'
NeoBundle 'altercation/vim-colors-solarized.git'
"" C++
NeoBundleLazy 'Rip-Rip/clang_complete', {
      \ 'autoload' : {'filetype' : ['cpp']}
      \ }
NeoBundleLazy 'osyo-manga/neocomplcache-clang_complete', {
      \ 'autoload' : {'filetype' : ['cpp']}
      \ }
"" Ruby
NeoBundleLazy 'tpope/vim-rails', {
      \ 'autoload' : {'filetype' : ['ruby']}
      \ }
NeoBundleLazy 'rhysd/neco-ruby-keyword-args', {
      \ 'autoload' : {'filetype' : ['ruby']}
      \ }
"" Dart snippets
NeoBundleLazy "git://github.com/osyo-manga/neocomplcache-snippets-complete-dart.git", {
      \ 'autoload' : {'filetype' : ['dart']}
      \ }
"" Dart syntax
NeoBundleLazy "git://github.com/vim-scripts/Dart.git", {
      \ 'autoload' : {'filetype' : ['dart']}
      \ }
"" Haskell
NeoBundleLazy 'ujihisa/neco-ghc', {
      \ 'depends' : ['Shougo/neocomplcache'],
      \ 'autoload' : {'filetype' : ['haskell']}
      \ }
NeoBundleLazy 'eagletmt/ghcmod-vim', {
      \ 'autoload' : {'filetype' : ['haskell']}
      \ }
"" mikutter_mode
if isdirectory(expand("~/workspace/vim/plugins/mikutter_mode.vim"))
NeoBundle 'mikutter_mode.vim', {
      \ "base": "~/workspace/vim/plugins",
      \ "type": "nosync"
      \ }
else
NeoBundle '2GMon/mikutter_mode.vim'
endif

filetype plugin indent on     " required!
" neobundleの設定ここまで}}}
" unite-neco {{{
let s:unite_source = {'name': 'neco'}
function! s:unite_source.gather_candidates(args, context)
  let necos = [
        \ "~(-'_'-) goes right",
        \ "~(-'_'-) goes right and left",
        \ "~(-'_'-) goes right quickly",
        \ "~(-'_'-) goes right then smile",
        \ "~(-'_'-)  -8(*'_'*) go right and left",
        \ "(=' .' ) ~w",
        \ ]
  return map(necos, '{
        \ "word": v:val,
        \ "source": "neco",
        \ "kind": "command",
        \ "action__command": "Neco " . v:key,
        \ }')
endfunction
call unite#define_source(s:unite_source)
"}}}


let g:quickrun_config = {}

" Vimの設定{{{
" ファイルエンコードの設定
set enc=utf-8
set fenc=utf-8
set fencs=utf-8,iso-2022-jp,euc-jp,sjis,jis
set fileformats=unix,dos,mac

set number          " 行番号表示
set showtabline=2   " タブページ常に表示
set noswapfile      " スワップファイル作らない
set nobackup        " バックアップファイル作らない
set showmatch       " 対応する括弧の表示
" デフォルトインデント
set autoindent smartindent
set shiftwidth=4
set expandtab
set tabstop=4
set backspace=indent,eol,start  " Backspaceで色々削除可能
" 不可視文字表示
set list
set listchars=tab:>-,trail:-
set whichwrap=b,s,h,l           " カーソルが行頭，行末で止まらない
" 全角文字をちゃんとあつかう
if has('gui_running')
  set ambiwidth=double
endif
" ファイルタイプ別設定
filetype on
filetype indent on
filetype plugin on
syntax on                       " syntaxカラー有効
syntax sync fromstart
set background=dark
colorscheme desert
set nrformats=alpha,octal,hex     " Ctrl+A, Ctrl+Xの加算減算で認識する基数
set wildmode=list,full            " exコマンド時，Tabで補完候補一覧
set undolevels=10000              " Undoの回数制限
" ステータスラインの設定
set statusline&
set statusline=%<%F\ %m%r%h%w%y%{'['.(&fenc!=''?&fenc:&enc).']['.&ff.']'}[POS=%l,%v,%p%%]
set statusline+=%{fugitive#statusline()}
set statusline+=%{g:NyanModoki()}
set statusline+=%=%{g:HahHah()}
set laststatus=2
let g:nyan_modoki_select_cat_face_number = 4
set showcmd               " 入力中のコマンド表示
setlocal bufhidden=delete " バッファ閉じた時に削除
set clipboard=unnamed,autoselect "無名レジスタを*レジスタにも入るように
nnoremap <ESC><ESC> :nohlsearch<CR> "<ESC><ESC>でハイライトオフ
" ,ssでカレントディレクトリをターミナルで開く
function! s:OpenMlterm()
  silent execute '!mlterm &'
endfunction
nnoremap <silent> ,ss :<C-u>call <SID>OpenMlterm()<CR>
nnoremap <silent> <C-c> :<C-u>lcd %:p:h<CR>
" 検索位置表示
nmap n <Plug>(anzu-n-with-echo)
nmap N <Plug>(anzu-N-with-echo)
nmap * <Plug>(anzu-star-with-echo)
nmap # <Plug>(anzu-sharp-with-echo)
cnoremap <C-a> <Home>
"" コマンドモードの設定
" 一文字戻る
cnoremap <C-b> <Left>
" カーソルの下の文字を削除
cnoremap <C-d> <Del>
" 行末へ移動
cnoremap <C-e> <End>
" 一文字進む
cnoremap <C-f> <Right>
" コマンドライン履歴を一つ進む
cnoremap <C-n> <Down>
" コマンドライン履歴を一つ戻る
cnoremap <C-p> <Up>
" 前の単語へ移動
cnoremap <M-b> <S-Left>
" 次の単語へ移動
cnoremap <M-f> <S-Right>
"}}}


" Uniteの設定{{{
let g:unite_source_menu_menus = {}
let g:unite_enable_start_insert=1 "入力モードで開始する
let g:unite_source_file_mru_limit=500 " 最近使ったファイルの最大値
let g:unite_source_history_yank_enable=1 " history/yankの有効化
"" ESC2回押すと終了する
au FileType unite nnoremap <silent> <buffer> <ESC><ESC> :q<CR>
au FileType unite inoremap <silent> <buffer> <ESC><ESC> <ESC>q<CR>
au FileType unite imap     <silent> <buffer> <C-w>      <Plug>(unite_delete_backward_path)
"" バッファ一覧
noremap <silent> ,ub :Unite buffer<CR>
"" ファイル一覧
noremap <silent> ,uf :UniteWithBufferDir -buffer-name=file file<CR>
"" 最近使ったファイルの一覧
noremap <silent> ,ur :Unite -buffer-name=register register<CR>
"" 最近使ったファイルの一覧
noremap <silent> ,um :Unite file_mru<CR>
"" 常用
noremap <silent> ,uu :Unite buffer file_mru<CR>
"" 全部
noremap <silent> ,ua :UniteWithBufferDir -buffer-name=files buffer file_mru<CR>
"" Colorscheme
noremap <silent> ,ucs :<C-u>Unite -no-quit -auto-preview colorscheme<CR>
"" history/yank
noremap <silent> ,uhy :<C-u>Unite history/yank<CR>
"" Tab一覧
noremap <silent> ,ut :<C-u>Unite tab:no-current<CR>
"" Line
noremap <silent> ,ul :<C-u>Unite line<CR>
noremap <silent> ,uL :<C-u>Unite line -no-quit<CR>
"" Outline
noremap <silent> ,uo :<C-u>Unite -no-start-insert -winheight=20 outline<CR>
"" help
noremap <silent> ,uhl :<C-u>Unite -winheight=40 help<CR>
"" unite-tag
noremap <silent> ,ug] :<C-u>execute 'Unite tag:' . expand('<cword>')<CR>
"" listing Project file
nnoremap <silent> ,up :<C-u>call <SID>unite_project('-start-insert')<CR>
function! s:unite_project(...)
  let opts = (a:0 ? join(a:000, ' ') : '')
  let dir = unite#util#path2project_directory(expand('%'))
  execute 'Unite' opts 'file_rec:' . dir
endfunction
"" encode変更
let g:unite_source_menu_menus.enc = {
      \ 'description': 'set enc=...',
      \ }
let g:unite_source_menu_menus.enc.candidates = {
      \ 'euc-jp': 'edit ++enc=euc-jp',
      \ 'utf-8' : 'edit ++enc=utf-8',
      \ }
function g:unite_source_menu_menus.enc.map(key, value)
  return {
        \ 'word': a:key, 'kind': 'command',
        \ 'action__command': a:value,
        \ }
endfunction
nnoremap <silent> ,uenc :<C-u>Unite menu:enc<CR>
"" fileencode変更
let g:unite_source_menu_menus.fenc = {
      \ 'description': 'set fenc=...',
      \ }
let g:unite_source_menu_menus.fenc.candidates = {
      \ 'euc-jp': 'set fenc=euc-jp',
      \ 'utf-8' : 'set fenc=utf-8',
      \ }
function g:unite_source_menu_menus.fenc.map(key, value)
  return {
        \ 'word': a:key, 'kind': 'command',
        \ 'action__command': a:value,
        \ }
endfunction
nnoremap <silent> ,ufenc :<C-u>Unite menu:fenc<CR>
"" encode変更
let g:unite_source_menu_menus.ff = {
      \ 'description': 'set ff=...',
      \ }
let g:unite_source_menu_menus.ff.candidates = {
      \ 'unix': 'set ff=unix',
      \ 'mac' : 'set ff=mac',
      \ 'dos' : 'set ff=dos',
      \ }
function g:unite_source_menu_menus.ff.map(key, value)
  return {
        \ 'word': a:key, 'kind': 'command',
        \ 'action__command': a:value,
        \ }
endfunction
nnoremap <silent> ,uff :<C-u>Unite menu:ff<CR>
"" よく編集するファイル
let g:unite_source_menu_menus = {
      \ "edit_frequently" : {
      \ "description" : "edit frequently",
      \ "command_candidates" : [
      \ ["edit vimrc", "edit $MYVIMRC"],
      \ ["edit gvimrc", "edit $MYGVIMRC"],
      \ ["edit vimperatorrc", "edit ~/.vimperatorrc"],
      \ ],
      \ },
      \}
nnoremap <silent> ,uef :<C-u>Unite menu:edit_frequently<CR>
"" Rails
nnoremap ,uR :<C-u>Unite rails/
"" Gtags
nnoremap <silent> ,ugg :<C-u>Unite gtags/context<CR>
"" DWMで開くアクション追加
let s:action = {
      \ 'description' : 'new dwm',
      \ 'is_selectable' : 1,
      \ }
function! s:action.func(candidates)"{{{
  for l:candidate in a:candidates
    call unite#util#command_with_restore_cursor('rightbelow split')
    call unite#take_action('open', candidate)
    call DWM_Focus()
  endfor
endfunction"}}}
call unite#custom_action('openable', 'dwm_new', s:action)
unlet s:action
"}}}


" neocomplcacheの設定{{{
let g:neocomplcache_enable_at_startup=1
let g:neocomplcache_force_overwrite_completefunc=1
inoremap <expr><CR>  neocomplcache#smart_close_popup() . "\<CR>"
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplcache#close_popup()
inoremap <expr><C-e>  neocomplcache#cancel_popup()
"" Enable omni completion.
augroup omni-setting
  autocmd!
  autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
  autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
  autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
  autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
  autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
augroup END
"" Enable heavy omni completion.
if !exists('g:neocomplcache_omni_patterns')
  let g:neocomplcache_omni_patterns = {}
endif
let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
let g:neocomplcache_omni_patterns.c = '\%(\.\|->\)\h\w*'
let g:neocomplcache_omni_patterns.cpp = '\h\w*\%(\.\|->\)\h\w*\|\h\w*::'
"}}}


" neosnippetの設定{{{
let g:neosnippet#snippets_directory = '~/.vim/snippets'
imap <C-k> <Plug>(neosnippet_expand_or_jump)
smap <C-k> <Plug>(neosnippet_expand_or_jump)
" }}}


" quickrunの設定 {{{
"" デフォルトオプション
""""" hookのロード後にUnite-quickfixを閉じる
""""" 失敗した場合quickfixの内容をUnite-quickfixで開く
""""" 実行終了時にquickfixを閉じる
""""" 失敗した場合にbufferを閉じる
""""" 出力が無かった場合にbufferを閉じる
""""" bufferを水平分割
""""" bufferとquickfix両方に出力する
""""" inuアニメーション有効
""""" inuアニメーションのwait time
""""" inuアニメ有効
""""" runnerをvimprocに
""""" vimprocの更新時間
""""" 無名バッファを実行した時でも行番号を置き換える http://d.hatena.ne.jp/osyo-manga/20120930/1348942193
"" watchdogsデフォルトオプション
""""" quickfixのみに出力
""""" u-nya-アニメ有効
""""" inuアニメ無効
"" watchdogs/rubyオプション
""""" unite-quickfixだとおかしくなるから普通のquickfixに出力
let g:quickrun_config = {
      \   "_" : {
      \     "hook/close_unite_quickfix/enable_hook_loaded" : 1,
      \     "hook/unite_quickfix/enable_failure" : 1,
      \     "hook/close_quickfix/enable_exit" : 1,
      \     "hook/close_buffer/enable_failure" : 1,
      \     "hook/close_buffer/enable_empty_data" : 1,
      \     "outputter/buffer/split" : ":botright 8sp",
      \     "outputter" : "multi:buffer:quickfix",
      \     "hook/inu/enable" : 1,
      \     "runner" : "vimproc",
      \     "runner/vimproc/updatetime" : 40,
      \     "hook/quickfix_replate_tempname_to_bufnr/enable_exit" : 1,
      \     "hook/quickfix_replate_tempname_to_bufnr/priority_exit" : -10,
      \   },
      \   "watchdogs_checker/_" : {
      \     "outputter" : "quickfix",
      \     "hook/u_nya_/enable" : 1,
      \     "hook/inu/enable" : 0,
      \     "hook/echo/enable" : 0,
      \     "hook/back_buffer/enable" : 0,
      \  },
      \   "watchdogs_checker/ruby" : {
      \     "hook/close_quickfix/enable_success" : 1,
      \     "hook/close_quickfix/enable_hook_loaded" : 1,
      \     "hook/close_unite_quickfix/enable_hook_loaded" : 0,
      \     "hook/unite_quickfix/enable_failure" : 0,
      \     "hook/close_quickfix/enable_exit" : 0,
      \   },
      \ }
" }}}


" watchdogs.vimの設定 {{{
call watchdogs#setup(g:quickrun_config)
"" 書き込み後にシンタックスチェックを行う
"" let g:watchdogs_check_BufWritePost_enable = 1
"" filetype ごとに有効無効を設定することも出来る
let g:watchdogs_check_BufWritePost_enables = {
      \   "cpp" : 1,
      \   "ruby" : 1,
      \   "haskell" : 0
      \ }
" }}}


" parteditの設定 {{{
let g:partedit#opener = 'split'
" }}}


" vimfiler {{{
let g:vimfiler_as_default_explorer=1
" }}}

"vimshell {{{
nnoremap <silent> ,vs :VimShellTab<CR>
nnoremap <silent> ,vsi :VimShellInteractive<CR>
" 選択中に,vss: 非同期で開いたインタプリタに選択行を評価させる
vmap <silent> ,vss :VimShellSendString<CR>
" ,vss: 非同期で開いたインタプリタに現在の行を評価させる
nnoremap <silent> ,vss <S-v>:VimShellSendString<CR>
"" vimshellの現在行の左上に表示するプロンプト
let g:vimshell_prompt = $USER."% "
"" vimshellの現在行の右上に表示するプロンプト
let g:vimshell_right_prompt = 'fnamemodify(getcwd(), ":~")'
"" vimshellの環境変数TERM
let g:vimshell_environment_term = 'vimshell'
"" vimshellを同じタブ内に開くときの分割Exコマンド(水平分割 20行)
let g:vimshell_split_command = 'split | resize 20'
"" Rファイルを開いてる時，VimShellInteractiveでR起動
call vimshell#set_dictionary_helper(
      \ g:vimshell_interactive_interpreter_commands, 'r', 'R')
" }}}


"errormarker.vimの設定 {{{
let errormarker_errortext = "!!"
let errormarker_warningtext = "??"
let errormarker_errorgroup = "ErrorMsg"
let errormarker_warninggroup = "Todo"
" }}}


" fugitiveの設定 {{{
noremap <silent> ,gs :<C-u>Gstatus<CR>
noremap ,gc :<C-u>Gcommit
" }}}


" Gitvの設定 {{{
nmap <leader>gv :Gitv --all<CR>
nmap <leader>gV :Gitv! --all<CR>
" }}}

" Gitqの設定 {{{
let g:gitq_config = {
      \ 'add/p': { 'runner' : 'shell', },
      \}
" }}}


" vim-arpeggioの設定 {{{
call arpeggio#load()
Arpeggio inoremap jk  <Esc>
Arpeggio nnoremap fj  <C-d>
Arpeggio nnoremap fk  <C-u>
" }}}

"" hl_matchitの設定 {{{
let g:hl_matchit_enable_on_vim_startup = 1
let g:hl_matchit_hl_groupname = 'Title'
let g:hl_matchit_allow_ft_regexp = 'html\|vim\|ruby\|sh'
" }}}

" Vim {{{
augroup vim-setting
  autocmd!
  autocmd FileType vim set foldmethod=marker
augroup END
" }}}


" TXT {{{
augroup txt-textwidth
  autocmd!
  autocmd BufRead *.txt setlocal fo+=mM
  autocmd BufRead *.txt setlocal textwidth=80
augroup END
" }}}


" C++ {{{
"" clang_complete
augroup cpp-setting
  autocmd!
  autocmd FileType cpp let b:match_words = &matchpairs . b:match_words . ",<:>"
augroup END
let g:clang_complete_auto=1
let g:clang_use_library=0
let g:clang_exec='/usr/bin/clang'
let g:clang_user_options='2>/dev/null || exit 0'
set completeopt=menuone " こうしないと候補選択時に Scratch ウィンドウが開く
" }}}


" Ruby {{{
augroup ruby-setting
  autocmd!
  autocmd FileType ruby setlocal shiftwidth=2
  autocmd FileType ruby setlocal tabstop=2
  autocmd FileType eruby setlocal shiftwidth=2
  autocmd FileType eruby setlocal tabstop=2
augroup END
" }}}


" Dart {{{
augroup dart-setting
  autocmd!
  autocmd BufNewFile,BufRead *.dart setfiletype dart " .dartのファイルを開いた時にファイルタイプ設定
augroup END
let s:dart_cmd = "$DART_SDK/bin/dart" " dartのパス
let g:quickrun_config['dart'] = {'command' : s:dart_cmd} " quickrunにdartのパスを設定
" }}}


" Haskell {{{
augroup haskell-setting
  autocmd!
  autocmd BufWritePost *.hs GhcModCheckAsync
  autocmd FileType haskell noremap <buffer><silent> ,gmt :GhcModType<CR>
  autocmd FileType haskell noremap <buffer><silent> ,gmtc :GhcModTypeClear<CR>
  autocmd FileType haskell noremap <buffer><silent> ,gmc :GhcModCheck<CR>
augroup END
" }}}


" TeX {{{
augroup tex-mapping
  autocmd!
  autocmd FileType tex nnoremap <buffer><C-o> :Unite -no-quite -no-start-insert -winheight=10 outline<CR>
augroup END
" }}}


" snippet {{{
augroup snippets-setting
  autocmd!
  autocmd FileType snippet setlocal noexpandtab
augroup END
" }}}
